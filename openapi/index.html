<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">

    

    <title>Mu-Haskell: OpenAPI / REST services</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Mu is a purely functional library for building microservices.">
    <meta name="keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory">

    <meta property="og:image" content="/mu-haskell/img/poster.png" />
    <meta property="og:title" content="Mu-Haskell: OpenAPI / REST services" />
    <meta property="og:site_name" content="Mu-Haskell: OpenAPI / REST services" />
    <meta property="og:url" content="https://higherkindess.io/mu-haskell" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="Mu is a purely functional library for building microservices." />
    <meta property="og:keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory" />

    <meta name="twitter:text:description" content="Mu is a purely functional library for building microservices." />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@47deg">
    <meta name="twitter:creator" content="@47deg">
    <meta name="twitter:image" content="/mu-haskell/img/poster.png" />

    <meta property="github-info" data-github-owner="higherkindness" data-github-repo="mu-haskell" />

    <script defer src="/mu-haskell/js/docs.js"></script>

    <!-- Favicon -->
    <link rel="shortcut icon" href="/mu-haskell/img/favicon.png">

    <!-- mu-haskell docs css -->
    <link rel="stylesheet" type="text/css" href="/mu-haskell/css/docs.css">
</head>

    <body>
        <div id="site-sidebar" class="site-sidebar">
  <div class="sidebar-brand">
    <a href="/mu-haskell/" class="brand" title="Mu-Haskell">
      <img
        src="/mu-haskell/img/nav-brand-white.svg"
        alt="Mu-Haskell"
        class="brand-wrapper"
      />
      <span>Mu-Haskell</span>
    </a>
    <button
      id="main-toggle"
      type="button"
      title="Close"
      class="button sidebar-toggle"
    >
      <span class="close"></span>
    </button>
  </div>
  <div class="sidebar-menu">
    
      

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
      
      <a
        href="/mu-haskell/"
        class=""
        title="Start"
      >
        Start
      </a>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Introduction"
        class="button drop-nested"
      >
        Introduction
      </button>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/intro-rpc/"
          title="For RPC"
        >
          For RPC
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/intro-graphql/"
          title="For GraphQL"
        >
          For GraphQL
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <a
        href="/mu-haskell/schema/"
        title="Schemas"
        class="drop-nested"
      >
        Schemas
      </a>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/serializers/"
          title="Serialization formats"
        >
          Serialization formats
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/registry/"
          title="Registry"
        >
          Registry
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/optics/"
          title="Mu-Optics"
        >
          Mu-Optics
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  open">
       
      <a
        href="/mu-haskell/rpc/"
        title="Services"
        class="drop-nested"
      >
        Services
      </a>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/grpc/server/"
          title="gRPC servers"
        >
          gRPC servers
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/grpc/client/"
          title="gRPC clients"
        >
          gRPC clients
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/graphql/"
          title="GraphQL"
        >
          GraphQL
        </a>
        
        
        
        <a
          class="active"
          href="/mu-haskell/openapi/"
          title="OpenAPI / REST"
        >
          OpenAPI / REST
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Integrations"
        class="button drop-nested"
      >
        Integrations
      </button>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/db/"
          title="Databases"
        >
          Databases
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/transformer/"
          title="Transformers"
        >
          Transformers
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/middleware/"
          title="Middleware"
        >
          Middleware
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
      
      <a
        href="/mu-haskell/talks/"
        class=""
        title="Talks"
      >
        Talks
      </a>
      
    </div>
    
    
  </div>
</div>

        <main id="site-doc" class="site-doc">
    <div class="doc-header">
      <button
        id="menu-toggle"
        type="button"
        class="button doc-toggle"
        title="Toggle">
          <img src="/mu-haskell/img/sidebar-icon-open.svg" alt="Toggle" title="Toggle">
      </button>

      <div class="link-container">
        
        <div id="version-dropdown" class="link-item">

    <button class="button link-like strong" onclick="openDropdown(event)" title="Version">
      
        <i class="nav-item-icon fa fa-lg " aria-hidden="true"></i>
        <span class="nav-item-text">Version</span>
      
    </button>

    <ul class="dropdown dropdown-content">
      
      <li class="dropdown-item">
        <a class="dropdown-item-link" title="Stable" href="https://higherkindness.io/mu-haskell/" target="_blank" rel="noopener noreferrer">
            <span>
              Stable
            </span>
        </a>
      </li>
      
      <li class="dropdown-item">
        <a class="dropdown-item-link" title="Next" href="https://higherkindness.io/mu-haskell/wip" target="_blank" rel="noopener noreferrer">
            <span>
              Next
            </span>
        </a>
      </li>
      
    </ul>

</div>

        
        <div id="api-docs-dropdown" class="link-item">

    <button class="button link-like strong" onclick="openDropdown(event)" title="API Docs">
      
        <i class="nav-item-icon fa fa-lg " aria-hidden="true"></i>
        <span class="nav-item-text">API Docs</span>
      
    </button>

    <ul class="dropdown dropdown-content">
      
      <li class="dropdown-item">
        <a class="dropdown-item-link" title="Stable" href="https://higherkindness.io/mu-haskell/haddock" target="_blank" rel="noopener noreferrer">
            <span>
              Stable
            </span>
        </a>
      </li>
      
      <li class="dropdown-item">
        <a class="dropdown-item-link" title="Next" href="https://higherkindness.io/mu-haskell/wip/haddock" target="_blank" rel="noopener noreferrer">
            <span>
              Next
            </span>
        </a>
      </li>
      
    </ul>

</div>

        
        <div class="link-item">
          <a href="https://github.com/higherkindness/mu-haskell" title="GitHub repo" target="_blank" rel="noopener noreferrer">
            <span class="strong">GitHub</span>
            <span id="stars-count"></span>
          </a>
        </div>
      </div>

    </div>
    <div class="doc-content">
        <h1 id="openapi--rest-services">OpenAPI / REST services</h1>

<p>In order to expose a Mu server using a OpenAPI or REST interface, we make use of the awesome <a href="https://docs.servant.dev/en/stable/">Servant</a> library. Both libraries describe the API of a server at the type level, use the notion of <em>handlers</em>, and follow a similar structure.</p>

<p>The <code class="highlighter-rouge">mu-servant-server</code> package contains a function <code class="highlighter-rouge">servantServerHandlers</code> which unpacks the Mu handlers and repackages them as Servant handlers, with some minor changes to support streaming. The trickiest part, however, is translating the Mu server <em>type</em> into a Servant server <em>type</em>.</p>

<h2 id="annotating-the-server">Annotating the server</h2>

<p>When Mu methods are converted to Servant APIs, you may customize certain aspects of the resulting API, including the route, HTTP method, and HTTP status.  Additionally, you must specify which content types use be used when encoding and decoding each type in your schema that appears in your methods. All of this customization is done with annotations, via the <code class="highlighter-rouge">AnnotatedSchema</code> and <code class="highlighter-rouge">AnnotatedPackage</code> type families.</p>

<p>For the server we have developed in the <a href="/mu-haskell/rpc/">generic RPC section</a>, the instances for the services look as follows:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kr">instance</span> <span class="kt">AnnotatedPackage</span> <span class="kt">ServantRoute</span> <span class="kt">QuickstartService</span>
  <span class="o">=</span> <span class="sc">'[</span><span class="err"> </span><span class="kt">'AnnService</span> <span class="s">"Greeter"</span> <span class="p">(</span><span class="kt">'ServantTopLevelRoute</span> <span class="sc">'[</span><span class="err">"</span><span class="n">greet</span><span class="s">"])
     , 'AnnMethod "</span><span class="kt">Greeter</span><span class="s">" "</span><span class="kt">SayHello</span><span class="s">"
                   ('ServantRoute '["</span><span class="n">say</span><span class="s">", "</span><span class="n">hello</span><span class="s">"] 'POST 200),
     ]
</span></code></pre></div></div>

<p>The first annotation defines that the whole service lives in the <code class="highlighter-rouge">/greet</code> route. Each method then gets its own route and HTTP verb. To execute <code class="highlighter-rouge">SayHello</code>, one has to make a <code class="highlighter-rouge">POST</code> request to <code class="highlighter-rouge">/greet/say/hello</code>. The last element is the HTTP status code to be returned by default, in this case <code class="highlighter-rouge">200</code> which means success.</p>

<p>You also need to define how message types can be serialized in the API. This will be translated to a <code class="highlighter-rouge">ReqBody</code> in the corresponding Servant API, which requires a list of acceptable content types for the request. We provide a <code class="highlighter-rouge">DefaultServantContentTypes</code> which uses JSON for both unary and streaming calls.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kr">instance</span>
  <span class="kt">AnnotatedSchema</span> <span class="kt">ServantContentTypes</span> <span class="kt">QuickstartSchema</span> <span class="o">=</span>
    <span class="sc">'[</span><span class="err"> </span><span class="kt">'AnnType</span> <span class="s">"HelloRequest"</span>  <span class="kt">DefaultServantContentTypes</span><span class="p">,</span>
       <span class="kt">'AnnType</span> <span class="s">"HelloResponse"</span> <span class="kt">DefaultServantContentTypes</span>
     <span class="p">]</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">MimeRender</code>/<code class="highlighter-rouge">MimeUnrender</code> instances necessary to perform this encoding/decoding must exist for the Haskell type you use to represent messages. In this case, that means that both types must support conversion to JSON, which can be achieved using <code class="highlighter-rouge">mu-schema</code> in combination with <code class="highlighter-rouge">DerivingVia</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# language DerivingVia #-}</span>

<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Aeson</span> <span class="k">as</span> <span class="n">J</span>
<span class="kr">import</span> <span class="nn">Mu.Adapter.Json</span> <span class="p">()</span>

<span class="kr">newtype</span> <span class="kt">HelloRequest</span> <span class="o">=</span> <span class="kt">HelloRequest</span> <span class="p">{</span> <span class="n">name</span> <span class="o">::</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Text</span> <span class="p">}</span>
  <span class="kr">deriving</span> <span class="p">(</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Generic</span>
           <span class="p">,</span> <span class="kt">ToSchema</span>   <span class="kt">QuickstartSchema</span> <span class="s">"HelloRequest"</span>
           <span class="p">,</span> <span class="kt">FromSchema</span> <span class="kt">QuickstartSchema</span> <span class="s">"HelloRequest"</span> <span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">J</span><span class="o">.</span><span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">J</span><span class="o">.</span><span class="kt">FromJSON</span><span class="p">)</span>
    <span class="n">via</span> <span class="p">(</span><span class="kt">WithSchema</span> <span class="kt">QuickstartSchema</span> <span class="s">"HelloRequest"</span> <span class="kt">HelloRequest</span><span class="p">)</span>
</code></pre></div></div>

<p>If you forget to provide one of these required instances, you will see a message like the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    • Missing required AnnotatedPackage ServantRoute type instance
      for "myschema" package
    • When checking the inferred type
</code></pre></div></div>

<p>followed by a large and difficult to read type representing several stuck type families.  This message is an indication that you must provide an <code class="highlighter-rouge">AnnotatedPackage</code> type instance, with a domain of <code class="highlighter-rouge">ServantRoute</code> for the package with the name <code class="highlighter-rouge">myschema</code>.</p>

<h2 id="exposing-the-server">Exposing the server</h2>

<p>You are now ready to expose your server using Servant!</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Mu.Servant.Server</span>
<span class="kr">import</span> <span class="nn">Servant.Server</span>

<span class="n">main</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">api</span>    <span class="o">=</span> <span class="n">packageAPI</span> <span class="p">(</span><span class="n">quickstartServer</span> <span class="o">@</span><span class="kt">ServerErrorIO</span><span class="p">)</span>
      <span class="n">server</span> <span class="o">=</span> <span class="n">servantServerHandlers</span> <span class="n">toHandler</span> <span class="n">quickstartServer</span>
  <span class="kr">in</span> <span class="n">run</span> <span class="mi">8081</span> <span class="p">(</span><span class="n">serve</span> <span class="n">api</span> <span class="n">server</span><span class="p">)</span>
</code></pre></div></div>

<p>The last line uses functions from Servant and Warp to run the server. The <code class="highlighter-rouge">serve</code> function has two parameters:</p>
<ul>
  <li>One is the definition of the API, which can be obtained using the provided <code class="highlighter-rouge">packageAPI</code> with your server. In this case we had to make explicit the monad we are operating to avoid an ambiguity error.</li>
  <li>The other is the set of Servant handlers, which can be obtained by using <code class="highlighter-rouge">servantServerHandlers toHandler</code>.</li>
</ul>

<h2 id="integration-with-swagger-ui">Integration with Swagger UI</h2>

<p>You can easily expose not only the server itself, but also its <a href="https://swagger.io/">Swagger / OpenAPI</a> schema easily, alongside a <a href="https://swagger.io/tools/swagger-ui/">Swagger UI</a> for testing purposes. Here we make use of the awesome <a href="https://github.com/haskell-servant/servant-swagger-ui"><code class="highlighter-rouge">servant-swagger-ui</code> package</a>.</p>

<p>First of all, you need to specify that you want an additional component in your Servant API. You do so in the annotation:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kr">instance</span> <span class="kt">AnnotatedPackage</span> <span class="kt">ServantRoute</span> <span class="kt">QuickstartService</span>
  <span class="o">=</span> <span class="sc">'[</span><span class="err"> </span><span class="kt">'AnnPackage</span> <span class="p">(</span><span class="kt">'ServantAdditional</span> <span class="p">(</span><span class="kt">SwaggerSchemaUI</span> <span class="s">"swagger-ui"</span> <span class="s">"swagger.json"</span><span class="p">))</span>
     <span class="p">,</span> <span class="cm">{- rest of annotations -}</span> <span class="p">]</span>
</code></pre></div></div>

<p>The implementation of this additional component is given by using <code class="highlighter-rouge">servantServerHandlersExtra</code>, instead of its “non-extra” version. The aforementioned package is ready for consumption in that way:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Mu.Servant.Server</span>
<span class="kr">import</span> <span class="nn">Servant.Server</span>
<span class="kr">import</span> <span class="nn">Servant.Swagger.UI</span>

<span class="n">main</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">svc</span>    <span class="o">=</span> <span class="n">quickstartServer</span> <span class="o">@</span><span class="kt">ServerErrorIO</span>
      <span class="n">api</span>    <span class="o">=</span> <span class="n">packageAPI</span> <span class="n">svc</span>
      <span class="n">server</span> <span class="o">=</span> <span class="n">servantServerHandlersExtra</span>
                <span class="p">(</span><span class="n">swaggerSchemaUIServer</span> <span class="p">(</span><span class="n">swagger</span> <span class="n">svc</span><span class="p">))</span>
                <span class="n">toHandler</span> <span class="n">svc</span>
  <span class="kr">in</span> <span class="n">run</span> <span class="mi">8081</span> <span class="p">(</span><span class="n">serve</span> <span class="n">api</span> <span class="n">server</span><span class="p">)</span>
</code></pre></div></div>

<p>And that’s all! When you users surf to <code class="highlighter-rouge">yourserver/swagger-ui</code> they’ll see a color- and featureful explanation of the endpoints of your server.</p>

<h2 id="type-translation">Type translation</h2>

<blockquote>
  <p>This is not required for using <code class="highlighter-rouge">mu-servant-server</code>, but may help you understanding how it works under the hood and diagnosing problems.</p>
</blockquote>

<p>There are essentially four categories of <code class="highlighter-rouge">Method</code> types and each of these is translated slightly differently.</p>

<h3 id="full-unary">Full unary</h3>

<p>Full unary methods have non-streaming arguments and a non-streaming response. Most HTTP endpoints expect unary requests and return unary responses. Unary method handlers look like this</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">MonadServer</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">requestType</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">responseType</span>
</code></pre></div></div>

<p>For a handler like this, the corresponding “Servant” API type would be</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">MyUnaryAPI</span> <span class="o">=</span>
  <span class="n">route</span> <span class="o">:&gt;</span>
    <span class="kt">ReqBody</span> <span class="n">ctypes1</span> <span class="n">requestType</span> <span class="o">:&gt;</span>
      <span class="kt">Verb</span> <span class="n">method</span> <span class="n">status</span> <span class="n">ctypes2</span> <span class="n">responseType</span>
</code></pre></div></div>

<p>As you can see, the request body contains a <code class="highlighter-rouge">requestType</code> value, and the response body contains a <code class="highlighter-rouge">responseType</code> value. All other types are derived from Mu annotations.</p>

<h3 id="server-streaming">Server streaming</h3>

<p>Server streaming methods have non-streaming arguments, but the response is streamed back to the client. Server stream handlers look like this</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">MonadServer</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">requestType</span> <span class="o">-&gt;</span> <span class="kt">ConduitT</span> <span class="n">responseType</span> <span class="kt">Void</span> <span class="n">m</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
</code></pre></div></div>

<p>For a handler like this, the corresponding Servant API type would be</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">MyServerStreamAPI</span> <span class="o">=</span>
  <span class="n">route</span> <span class="o">:&gt;</span>
    <span class="kt">ReqBody</span> <span class="n">ctypes</span> <span class="n">requestType</span> <span class="o">:&gt;</span>
      <span class="kt">Stream</span> <span class="n">method</span> <span class="n">status</span> <span class="n">framing</span> <span class="n">ctype</span> <span class="p">(</span><span class="kt">SourceIO</span> <span class="p">(</span><span class="kt">StreamResult</span> <span class="n">responseType</span><span class="p">))</span>
</code></pre></div></div>

<p>The request body contains a <code class="highlighter-rouge">requestType</code> value. The response body is a stream of <code class="highlighter-rouge">StreamResult</code> responseType@ values. <code class="highlighter-rouge">StreamResult responseType</code> contains either a <code class="highlighter-rouge">responseType</code> value or an error message describing a problem that occurred while producing <code class="highlighter-rouge">responseType</code> values. All other types are derived from Mu annotations.</p>

<h3 id="client-streaming">Client streaming</h3>

<p>Client streaming methods have a streaming argument, but the response is unary. Client stream handlers look like this</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">MonadServer</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">ConduitT</span> <span class="nb">()</span> <span class="n">requestType</span> <span class="n">m</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">responseType</span>
</code></pre></div></div>

<p>For a handler like this, the corresponding Servant API type would be</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">MyClientStreamAPI</span> <span class="o">=</span>
  <span class="n">route</span> <span class="o">:&gt;</span>
    <span class="kt">StreamBody</span> <span class="n">framing</span> <span class="n">ctype</span> <span class="p">(</span><span class="kt">SourceIO</span> <span class="n">requestType</span><span class="p">)</span> <span class="o">:&gt;</span>
      <span class="kt">Verb</span> <span class="n">method</span> <span class="n">status</span> <span class="n">ctypes</span> <span class="n">responseType</span>
</code></pre></div></div>

<h3 id="bidirectional-streaming">Bidirectional streaming</h3>

<p>Bidirectional streaming method have a streaming argument and a streaming response. Bidirectional stream handlers look like this</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">(</span><span class="kt">MonadServer</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">ConduitT</span> <span class="nb">()</span> <span class="n">requestType</span> <span class="n">m</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="kt">ConduitT</span> <span class="n">responseType</span> <span class="kt">Void</span> <span class="n">m</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="nb">()</span>
</code></pre></div></div>

<p>For a handler like this, the corresponding Servant API type would be</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">MyBidirectionalStreamAPI</span> <span class="o">=</span>
  <span class="kt">StreamBody</span> <span class="n">framing1</span> <span class="n">ctype1</span> <span class="p">(</span><span class="kt">SourceIO</span> <span class="n">requestType</span><span class="p">)</span> <span class="o">:&gt;</span>
    <span class="kt">Stream</span> <span class="n">method</span> <span class="n">status</span> <span class="n">framing2</span> <span class="n">ctype2</span> <span class="p">(</span><span class="kt">SourceIO</span> <span class="p">(</span><span class="kt">StreamResult</span> <span class="n">responseType</span><span class="p">))</span>
</code></pre></div></div>

<p>This type should look familiar if you already looked at the server streaming and client streaming examples. The request body is a stream of <code class="highlighter-rouge">requestType</code> values, and the response body is a stream of <code class="highlighter-rouge">StreamResult responseType</code> values. All the other types involved are derived from Mu annotations.</p>


    </div>
</main>

    </body>
</html>
