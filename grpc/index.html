<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">
    <title>Mu-Haskell</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Mu is a purely functional library for building microservices.">
    <meta name="keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory">

    <meta property="og:image" content="/mu-haskell/img/poster.png" />
    <meta property="og:title" content="Mu-Haskell" />
    <meta property="og:site_name" content="Mu-Haskell" />
    <meta property="og:url" content="https://higherkindness.io/mu-haskell" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="Mu is a purely functional library for building microservices." />
    <meta property="og:keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory" />

    <meta name="twitter:text:description" content="Mu is a purely functional library for building microservices." />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@47deg">
    <meta name="twitter:creator" content="@47deg">
    <meta name="twitter:image" content="/mu-haskell/img/poster.png" />

    <script defer src="/mu-haskell/js/docs.js"></script>

    <!-- Favicon -->
    <link rel="shortcut icon" href="/mu-haskell/img/favicon.png">

    <!-- mu-haskell docs css -->
    <link rel="stylesheet" type="text/css" href="/mu-haskell/css/docs.css">
</head>

    <body>
        <div id="site-sidebar">
  <div class="sidebar-brand">
    <a href="/mu-haskell/" class="brand" title="Mu-Haskell">
      <img
        src="/mu-haskell/img/nav-brand-white.svg"
        alt="Mu-Haskell"
        class="brand-wrapper"
      />
      <span>Mu-Haskell</span>
    </a>
    <button
      id="main-toggle"
      type="button"
      title="Close"
      class="button sidebar-toggle"
    >
      <span class="close"></span>
    </button>
  </div>
  <div class="sidebar-menu">
    
      

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
      
      <a
        href="/mu-haskell/"
        class=""
        title="Start"
      >
        Start
      </a>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
      
      <a
        href="/mu-haskell/intro/"
        class=""
        title="Introduction"
      >
        Introduction
      </a>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <a
        href="/mu-haskell/schema/"
        title="Schemas"
        class="drop-nested"
      >
        Schemas
      </a>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/registry/"
          title="Registry"
        >
          Registry
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  open">
       
      <a
        href="/mu-haskell/rpc/"
        title="Services and servers"
        class="drop-nested"
      >
        Services and servers
      </a>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class="active"
          href="/mu-haskell/grpc/"
          title="gRPC"
        >
          gRPC
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/stream/"
          title="Streams"
        >
          Streams
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/db/"
          title="Databases"
        >
          Databases
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Integrations"
        class="button drop-nested"
      >
        Integrations
      </button>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/transformer/"
          title="Transformers"
        >
          Transformers
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/middleware/"
          title="Middleware"
        >
          Middleware
        </a>
        
      </div>
      
    </div>
    
    
  </div>
</div>

        <main id="site-doc">
    <div class="doc-header">
      <button
        id="menu-toggle"
        type="button"
        class="button doc-toggle"
        title="Toggle">
          <img src="/mu-haskell/img/sidebar-icon-open.svg" alt="Toggle">
      </button>

      <div class="link-container">
        <div class="link-item">
          <a href="/mu-haskell/haddock/index.html">API Docs</a>
        </div>
        <div class="link-item">
          <a href="https://github.com/higherkindness/mu-haskell">GitHub</a>
        </div>
      </div>

    </div>
    <div class="doc-content">
        <h1 id="grpc-servers-and-clients">gRPC servers and clients</h1>

<p>Mu-Haskell defines a generic notion of service and server that implements it. This generic server can then be used by <code class="highlighter-rouge">mu-grpc-server</code>, to provide a concrete implementation using a specific wire format. Or you can use <code class="highlighter-rouge">mu-grpc-client</code> to build a client.</p>

<h2 id="running-the-server-with-mu-grpc">Running the server with <code class="highlighter-rouge">mu-grpc</code></h2>

<p>The combination of the declaration of a service API and a corresponding implementation as a <code class="highlighter-rouge">Server</code> may be served directly using a concrete wire protocol. One example is gRPC, provided by our sibling library <code class="highlighter-rouge">mu-grpc</code>. The following line starts a server at port <code class="highlighter-rouge">8080</code>, where the service can be found under the package name <code class="highlighter-rouge">helloworld</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span> <span class="n">runGRpcApp</span> <span class="mi">8080</span> <span class="s">"helloworld"</span> <span class="n">quickstartServer</span>
</code></pre></div></div>

<h2 id="building-a-client">Building a client</h2>

<p>Right now there are two options for building clients: using records or with <code class="highlighter-rouge">TypeApplications</code>. To give a proper introduction to both options let‚Äôs consider in detail an example client for the following services:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">service</span> <span class="n">Service</span> <span class="p">{</span>
  <span class="k">rpc</span> <span class="n">getPerson</span> <span class="p">(</span><span class="n">PersonRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Person</span><span class="p">);</span>
  <span class="k">rpc</span> <span class="n">newPerson</span> <span class="p">(</span><span class="n">Person</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">PersonRequest</span><span class="p">);</span>
  <span class="k">rpc</span> <span class="n">allPeople</span> <span class="p">(</span><span class="n">google.protobuf.Empty</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">stream</span> <span class="n">Person</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Regardless of the approach we decide to use, we can construct a basic CLI for the client this way:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">System.Environment</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="n">config</span> <span class="o">=</span> <span class="n">grpcClientConfigSimple</span> <span class="s">"127.0.0.1"</span> <span class="mi">8080</span> <span class="kt">False</span>
  <span class="kt">Right</span> <span class="n">client</span> <span class="o">&lt;-</span> <span class="n">setupGrpcClient'</span> <span class="n">config</span>
  <span class="n">args</span> <span class="o">&lt;-</span> <span class="n">getArgs</span>
  <span class="kr">case</span> <span class="n">args</span> <span class="kr">of</span>
    <span class="p">[</span><span class="s">"watch"</span><span class="p">]</span>       <span class="o">-&gt;</span> <span class="n">watching</span> <span class="n">client</span>
    <span class="p">[</span><span class="s">"get"</span><span class="p">,</span> <span class="n">idp</span><span class="p">]</span>    <span class="o">-&gt;</span> <span class="n">get</span> <span class="n">client</span> <span class="n">idp</span>
    <span class="p">[</span><span class="s">"add"</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">ag</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">add</span> <span class="n">client</span> <span class="n">nm</span> <span class="n">ag</span>
    <span class="kr">_</span>               <span class="o">-&gt;</span> <span class="n">putStrLn</span> <span class="s">"unknown command"</span>
</code></pre></div></div>

<p>Where <code class="highlighter-rouge">watch</code>, <code class="highlighter-rouge">get</code> and <code class="highlighter-rouge">add</code> are the only valid 3 commands that our CLI is going to accept and call each respective service.</p>

<h3 id="using-records">Using records</h3>

<p>This option is a bit more verbose but it‚Äôs also more explicit with the types and <em>‚Äúa bit more magic‚Äù</em> than the one with <code class="highlighter-rouge">TypeApplications</code> (due to the use of Generics).</p>

<p>We need to define a new record type (hence the name) that declares the services our client is going to consume. The names of the fields <strong>must</strong> match the names of the methods in the service, optionally prefixed by a <strong>common</strong> string. The prefix may also be empty, which means that the names in the record are exactly those in the service definition. In this case, we are prepending <code class="highlighter-rouge">call_</code> to each of them:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">GHC.Generics</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Mu.GRpc.Client.Record</span>

<span class="kr">data</span> <span class="kt">Call</span> <span class="o">=</span> <span class="kt">Call</span>
  <span class="p">{</span> <span class="n">call_getPerson</span> <span class="o">::</span> <span class="kt">MPersonRequest</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">GRpcReply</span> <span class="kt">MPerson</span><span class="p">)</span>
  <span class="p">,</span> <span class="n">call_newPerson</span> <span class="o">::</span> <span class="kt">MPerson</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">GRpcReply</span> <span class="kt">MPersonRequest</span><span class="p">)</span>
  <span class="p">,</span> <span class="n">call_allPeople</span> <span class="o">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">ConduitT</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">GRpcReply</span> <span class="kt">MPerson</span><span class="p">)</span> <span class="kt">IO</span> <span class="nb">()</span><span class="p">)</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Generic</span>
</code></pre></div></div>

<p>Note that we had to derive <code class="highlighter-rouge">Generic</code>. We also need to tweak our <code class="highlighter-rouge">main</code> function a little bit:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">main :: IO ()
main = do
</span>   let config = grpcClientConfigSimple "127.0.0.1" 1234 False
<span class="gd">-  Right client &lt;- setupGrpcClient' config
</span><span class="gi">+  Right grpcClient &lt;- setupGrpcClient' config
+  let client = buildService @Service @"call_" grpcClient
</span>   args &lt;- getArgs
</code></pre></div></div>

<p>Instead of building our client directly, we need to call <code class="highlighter-rouge">buildService</code> (and enable <code class="highlighter-rouge">TypeApplications</code>) to create the actual gRPC client. There are two type arguments to be explicitly given: the first one is the <code class="highlighter-rouge">Service</code> definition we want a client for, and the second one is the prefix in the record (in our case, this is <code class="highlighter-rouge">call_</code>). In the case you want an empty prefix, you write <code class="highlighter-rouge">@""</code> in that second position.</p>

<p>After that, let‚Äôs have a look at an example implementation of the three service calls:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Text.Read</span> <span class="p">(</span><span class="nf">readMaybe</span><span class="p">)</span>

<span class="n">get</span> <span class="o">::</span> <span class="kt">Call</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">get</span> <span class="n">client</span> <span class="n">idPerson</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="n">req</span> <span class="o">=</span> <span class="kt">MPersonRequest</span> <span class="o">$</span> <span class="n">readMaybe</span> <span class="n">idPerson</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"GET: is there some person with id: "</span> <span class="o">++</span> <span class="n">idPerson</span> <span class="o">++</span> <span class="s">"?"</span>
  <span class="n">res</span> <span class="o">&lt;-</span> <span class="n">call_getPerson</span> <span class="n">client</span> <span class="n">req</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"GET: response was: "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">res</span>
</code></pre></div></div>

<p>Notice the use of <code class="highlighter-rouge">readMaybe</code> to convert the strings to the appropiate type in a safe manner! üëÜüèº</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span> <span class="o">::</span> <span class="kt">Call</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">add</span> <span class="n">client</span> <span class="n">nm</span> <span class="n">ag</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="n">p</span> <span class="o">=</span> <span class="kt">MPerson</span> <span class="kt">Nothing</span> <span class="p">(</span><span class="kt">Just</span> <span class="o">$</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="n">nm</span><span class="p">)</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="n">ag</span><span class="p">)</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"ADD: creating new person "</span> <span class="o">++</span> <span class="n">nm</span> <span class="o">++</span> <span class="s">" with age "</span> <span class="o">++</span> <span class="n">ag</span>
  <span class="n">res</span> <span class="o">&lt;-</span> <span class="n">call_newPerson</span> <span class="n">client</span> <span class="n">p</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"ADD: was creating successful? "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">res</span>

<span class="n">watching</span> <span class="o">::</span> <span class="kt">Call</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">watching</span> <span class="n">client</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">replies</span> <span class="o">&lt;-</span> <span class="n">call_allPeople</span> <span class="n">client</span>
  <span class="n">runConduit</span> <span class="o">$</span> <span class="n">replies</span> <span class="o">.|</span> <span class="kt">C</span><span class="o">.</span><span class="n">mapM_</span> <span class="n">print</span>
</code></pre></div></div>

<h3 id="using-typeapplications">Using <code class="highlighter-rouge">TypeApplications</code></h3>

<p>With <code class="highlighter-rouge">TypeApplications</code> none of the above is needed, all you need to do is call <code class="highlighter-rouge">gRpcCall</code> with the appropiate service name as a type-level string, and the rest just <em>magically</em> works! ‚ú®</p>

<p>If you are not familiar with <code class="highlighter-rouge">TypeApplications</code>, you can check <a href="https://www.reddit.com/r/haskell/comments/6ufnmr/scrap_your_proxy_arguments_with_typeapplications/">this</a>, <a href="https://blog.sumtypeofway.com/posts/fluent-polymorphism-type-applications.html">that</a> and <a href="https://kseo.github.io/posts/2017-01-08-visible-type-application-ghc8.html">this</a>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Mu.GRpc.Client.TyApps</span>

<span class="n">get</span> <span class="o">::</span> <span class="kt">GrpcClient</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">get</span> <span class="n">client</span> <span class="n">idPerson</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="n">req</span> <span class="o">=</span> <span class="kt">MPersonRequest</span> <span class="o">$</span> <span class="n">readMaybe</span> <span class="n">idPerson</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"GET: is there some person with id: "</span> <span class="o">++</span> <span class="n">idPerson</span> <span class="o">++</span> <span class="s">"?"</span>
  <span class="n">response</span> <span class="o">::</span> <span class="kt">GRpcReply</span> <span class="kt">MPerson</span>
    <span class="o">&lt;-</span> <span class="n">gRpcCall</span> <span class="o">@</span><span class="kt">Service</span> <span class="o">@</span><span class="s">"getPerson"</span> <span class="n">client</span> <span class="n">req</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"GET: response was: "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">response</span>
</code></pre></div></div>

<p>Notice that the type signatures of our functions needed to change to receive the <code class="highlighter-rouge">GrpcClient</code> as an argument, instead of our custom record type.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span> <span class="o">::</span> <span class="kt">GrpcClient</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">add</span> <span class="n">client</span> <span class="n">nm</span> <span class="n">ag</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="n">p</span> <span class="o">=</span> <span class="kt">MPerson</span> <span class="kt">Nothing</span> <span class="p">(</span><span class="kt">Just</span> <span class="o">$</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="n">nm</span><span class="p">)</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="n">ag</span><span class="p">)</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"ADD: creating new person "</span> <span class="o">++</span> <span class="n">nm</span> <span class="o">++</span> <span class="s">" with age "</span> <span class="o">++</span> <span class="n">ag</span>
  <span class="n">response</span> <span class="o">::</span> <span class="kt">GRpcReply</span> <span class="kt">MPersonRequest</span>
    <span class="o">&lt;-</span> <span class="n">gRpcCall</span> <span class="o">@</span><span class="kt">Service</span> <span class="o">@</span><span class="s">"newPerson"</span> <span class="n">client</span> <span class="n">p</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"ADD: was creating successful? "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">response</span>
</code></pre></div></div>

<p>We are being a bit more explicit with the types here (for example, <code class="highlighter-rouge">response :: GRpcReply MPersonRequest</code>) to help a bit the <code class="highlighter-rouge">show</code> function because GHC is not able to infer the type on its own.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">watching</span> <span class="o">::</span> <span class="kt">GrpcClient</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">watching</span> <span class="n">client</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">replies</span> <span class="o">&lt;-</span> <span class="n">gRpcCall</span> <span class="o">@</span><span class="kt">Service</span> <span class="o">@</span><span class="s">"allPeople"</span> <span class="n">client</span>
  <span class="n">runConduit</span> <span class="o">$</span> <span class="n">replies</span> <span class="o">.|</span> <span class="kt">C</span><span class="o">.</span><span class="n">mapM_</span> <span class="p">(</span><span class="n">print</span> <span class="o">::</span> <span class="kt">GRpcReply</span> <span class="kt">MPerson</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span><span class="p">)</span>
</code></pre></div></div>

<p>Here though, while mapping <code class="highlighter-rouge">print</code> to the <code class="highlighter-rouge">Conduit</code>, we needed to add a type annotation because the type was ambiguous‚Ä¶ I think it‚Äôs a small price to pay in exchange for the terseness. ü§ë</p>

<hr />

<p>To see a <strong>working example</strong> you can check all the code at the <a href="https://github.com/higherkindness/mu-haskell/tree/master/examples/with-persistent">example with persistent</a>.</p>

    </div>
</main>

    </body>
</html>
